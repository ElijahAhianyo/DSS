# Dss Utils

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
flowchart LR
utils-->core
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-DSS.utils.mathHelper.eps_denom-start--->
## DSS.utils.mathHelper.eps_denom

<!---Documatic-section-eps_denom-start--->
<!---Documatic-block-DSS.utils.mathHelper.eps_denom-start--->
<details>
	<summary><code>DSS.utils.mathHelper.eps_denom</code> code snippet</summary>

```python
def eps_denom(denom, eps=1e-17):
    denom_sign = denom.sign() + (denom == 0.0).type_as(denom)
    denom = denom_sign * torch.clamp(denom.abs(), eps)
    return denom
```
</details>
<!---Documatic-block-DSS.utils.mathHelper.eps_denom-end--->
<!---Documatic-section-eps_denom-end--->

# #
<!---Documatic-section-DSS.utils.mathHelper.eps_denom-end--->

<!---Documatic-section-DSS.utils.mathHelper.decompose_to_R_and_t-start--->
## DSS.utils.mathHelper.decompose_to_R_and_t

<!---Documatic-section-decompose_to_R_and_t-start--->
<!---Documatic-block-DSS.utils.mathHelper.decompose_to_R_and_t-start--->
<details>
	<summary><code>DSS.utils.mathHelper.decompose_to_R_and_t</code> code snippet</summary>

```python
def decompose_to_R_and_t(transform_mat, row_major=True):
    assert transform_mat.shape[-2:] == (4, 4), 'Expecting batches of 4x4 matrice'
    if not row_major:
        transform_mat = transform_mat.transpose(-2, -1)
    R = transform_mat[..., :3, :3]
    t = transform_mat[..., -1, :3]
    return (R, t)
```
</details>
<!---Documatic-block-DSS.utils.mathHelper.decompose_to_R_and_t-end--->
<!---Documatic-section-decompose_to_R_and_t-end--->

# #
<!---Documatic-section-DSS.utils.mathHelper.decompose_to_R_and_t-end--->

<!---Documatic-section-DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames-start--->
## DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames

<!---Documatic-section-estimate_pointcloud_local_coord_frames-start--->
<!---Documatic-block-DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames-start--->
<details>
	<summary><code>DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames</code> code snippet</summary>

```python
def estimate_pointcloud_local_coord_frames(pointclouds: Union[torch.Tensor, 'Pointclouds'], neighborhood_size: int=50, disambiguate_directions: bool=True, return_knn_result: bool=False) -> Tuple[torch.Tensor, torch.Tensor, Optional['KNN']]:
    (points_padded, num_points) = convert_pointclouds_to_tensor(pointclouds)
    (ba, N, dim) = points_padded.shape
    if dim != 3:
        raise ValueError('The pointclouds argument has to be of shape (minibatch, N, 3)')
    if (num_points <= neighborhood_size).any():
        raise ValueError('The neighborhood_size argument has to be' + ' >= size of each of the point clouds.')
    pcl_mean = points_padded.sum(1) / num_points[:, None]
    points_centered = points_padded - pcl_mean[:, None, :]
    knn_result = knn_points(points_padded, points_padded, lengths1=num_points, lengths2=num_points, K=neighborhood_size, return_nn=True)
    k_nearest_neighbors = knn_result.knn
    pt_mean = k_nearest_neighbors.mean(2, keepdim=True)
    central_diff = k_nearest_neighbors - pt_mean
    per_pts_diff = central_diff.view(-1, neighborhood_size, 3)
    (_, S, local_coord_frames) = batch_svd(per_pts_diff)
    curvature = S * S / neighborhood_size
    local_coord_frames = local_coord_frames.view(ba, N, dim, dim)
    curvature = curvature.view(ba, N, dim)
    curvature = curvature.flip(-1)
    local_coord_frames = local_coord_frames.flip(-1)
    if disambiguate_directions:
        n = _disambiguate_vector_directions(points_centered, k_nearest_neighbors, local_coord_frames[:, :, :, 0])
        z = _disambiguate_vector_directions(points_centered, k_nearest_neighbors, local_coord_frames[:, :, :, 2])
        y = torch.cross(n, z, dim=2)
        local_coord_frames = torch.stack((n, y, z), dim=3)
    if return_knn_result:
        return (curvature, local_coord_frames, knn_result)
    return (curvature, local_coord_frames)
```
</details>
<!---Documatic-block-DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames-end--->
<!---Documatic-section-estimate_pointcloud_local_coord_frames-end--->

# #
<!---Documatic-section-DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames-end--->

<!---Documatic-section-DSS.utils.mathHelper.estimate_pointcloud_normals-start--->
## DSS.utils.mathHelper.estimate_pointcloud_normals

<!---Documatic-section-estimate_pointcloud_normals-start--->
```mermaid
flowchart LR
DSS.utils.mathHelper.estimate_pointcloud_normals-->DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames
```

### Object Calls

* DSS.utils.mathHelper.estimate_pointcloud_local_coord_frames

<!---Documatic-block-DSS.utils.mathHelper.estimate_pointcloud_normals-start--->
<details>
	<summary><code>DSS.utils.mathHelper.estimate_pointcloud_normals</code> code snippet</summary>

```python
def estimate_pointcloud_normals(pointclouds: Union[torch.Tensor, 'Pointclouds'], neighborhood_size: int=50, disambiguate_directions: bool=True) -> torch.Tensor:
    (curvatures, local_coord_frames) = estimate_pointcloud_local_coord_frames(pointclouds, neighborhood_size=neighborhood_size, disambiguate_directions=disambiguate_directions)
    normals = local_coord_frames[:, :, :, 0]
    return normals
```
</details>
<!---Documatic-block-DSS.utils.mathHelper.estimate_pointcloud_normals-end--->
<!---Documatic-section-estimate_pointcloud_normals-end--->

# #
<!---Documatic-section-DSS.utils.mathHelper.estimate_pointcloud_normals-end--->

<!---Documatic-section-DSS.utils.__init__.gather_batch_to_packed-start--->
## DSS.utils.__init__.gather_batch_to_packed

<!---Documatic-section-gather_batch_to_packed-start--->
<!---Documatic-block-DSS.utils.__init__.gather_batch_to_packed-start--->
<details>
	<summary><code>DSS.utils.__init__.gather_batch_to_packed</code> code snippet</summary>

```python
def gather_batch_to_packed(data, batch_idx):
    if data.shape[0] > 1:
        _batch_idx = batch_idx.clone()
        idx_dims = _batch_idx.shape
        tensor_dims = data.shape
        if len(idx_dims) > len(tensor_dims):
            msg = 'batch_idx cannot have more dimensions than data. '
            msg += 'got shape %r and data has shape %r'
            raise ValueError(msg % (idx_dims, tensor_dims))
        if idx_dims != tensor_dims:
            new_dims = len(tensor_dims) - len(idx_dims)
            new_shape = idx_dims + (1,) * new_dims
            expand_dims = (-1,) + tensor_dims[1:]
            _batch_idx = _batch_idx.view(*new_shape)
            _batch_idx = _batch_idx.expand(*expand_dims)
        data = data.gather(0, _batch_idx)
    return data
```
</details>
<!---Documatic-block-DSS.utils.__init__.gather_batch_to_packed-end--->
<!---Documatic-section-gather_batch_to_packed-end--->

# #
<!---Documatic-section-DSS.utils.__init__.gather_batch_to_packed-end--->

<!---Documatic-section-DSS.utils.__init__.get_class_from_string-start--->
## DSS.utils.__init__.get_class_from_string

<!---Documatic-section-get_class_from_string-start--->
<!---Documatic-block-DSS.utils.__init__.get_class_from_string-start--->
<details>
	<summary><code>DSS.utils.__init__.get_class_from_string</code> code snippet</summary>

```python
def get_class_from_string(cls_str):
    import importlib
    i = cls_str.rfind('.')
    mod = importlib.import_module(cls_str[:i])
    clss = getattr(mod, cls_str[i + 1:])
    return clss
```
</details>
<!---Documatic-block-DSS.utils.__init__.get_class_from_string-end--->
<!---Documatic-section-get_class_from_string-end--->

# #
<!---Documatic-section-DSS.utils.__init__.get_class_from_string-end--->

<!---Documatic-section-DSS.utils.mathHelper.ndc_to_pix-start--->
## DSS.utils.mathHelper.ndc_to_pix

<!---Documatic-section-ndc_to_pix-start--->
<!---Documatic-block-DSS.utils.mathHelper.ndc_to_pix-start--->
<details>
	<summary><code>DSS.utils.mathHelper.ndc_to_pix</code> code snippet</summary>

```python
def ndc_to_pix(p, resolution):
    pix = resolution - ((p[..., :2] + 1.0) * resolution - 1.0) / 2
    return pix
```
</details>
<!---Documatic-block-DSS.utils.mathHelper.ndc_to_pix-end--->
<!---Documatic-section-ndc_to_pix-end--->

# #
<!---Documatic-section-DSS.utils.mathHelper.ndc_to_pix-end--->

<!---Documatic-section-DSS.utils.__init__.get_grid_uniform-start--->
## DSS.utils.__init__.get_grid_uniform

<!---Documatic-section-get_grid_uniform-start--->
<!---Documatic-block-DSS.utils.__init__.get_grid_uniform-start--->
<details>
	<summary><code>DSS.utils.__init__.get_grid_uniform</code> code snippet</summary>

```python
def get_grid_uniform(resolution, box_side_length=2.0):
    x = np.linspace(-0.5, 0.5, resolution) * box_side_length
    y = x
    z = x
    (xx, yy, zz) = np.meshgrid(x, y, z)
    grid_points = torch.tensor(np.vstack([xx.ravel(), yy.ravel(), zz.ravel()]).T, dtype=torch.float)
    return {'grid_points': grid_points.cuda(), 'shortest_axis_length': box_side_length, 'xyz': [x, y, z], 'shortest_axis_index': 0}
```
</details>
<!---Documatic-block-DSS.utils.__init__.get_grid_uniform-end--->
<!---Documatic-section-get_grid_uniform-end--->

# #
<!---Documatic-section-DSS.utils.__init__.get_grid_uniform-end--->

<!---Documatic-section-DSS.utils.__init__.mask_from_padding-start--->
## DSS.utils.__init__.mask_from_padding

<!---Documatic-section-mask_from_padding-start--->
<!---Documatic-block-DSS.utils.__init__.mask_from_padding-start--->
<details>
	<summary><code>DSS.utils.__init__.mask_from_padding</code> code snippet</summary>

```python
def mask_from_padding(num_points):
    batch_size = num_points.shape[0]
    mask_padded = torch.full((batch_size, num_points.max().item()), True, dtype=torch.bool, device=num_points.device)
    for b in range(batch_size):
        mask_padded[b, num_points[b]:] = False
    return mask_padded
```
</details>
<!---Documatic-block-DSS.utils.__init__.mask_from_padding-end--->
<!---Documatic-section-mask_from_padding-end--->

# #
<!---Documatic-section-DSS.utils.__init__.mask_from_padding-end--->

<!---Documatic-section-DSS.utils.io.save_ply-start--->
## DSS.utils.io.save_ply

<!---Documatic-section-save_ply-start--->
<!---Documatic-block-DSS.utils.io.save_ply-start--->
<details>
	<summary><code>DSS.utils.io.save_ply</code> code snippet</summary>

```python
def save_ply(filename, points, colors=None, normals=None, binary=True):
    assert points.ndim == 2
    if points.shape[-1] == 2:
        points = np.concatenate([points, np.zeros_like(points)[:, :1]], axis=-1)
    vertex = np.core.records.fromarrays(points.transpose(1, 0), names='x, y, z', formats='f4, f4, f4')
    num_vertex = len(vertex)
    desc = vertex.dtype.descr
    if normals is not None:
        assert normals.ndim == 2
        if normals.shape[-1] == 2:
            normals = np.concatenate([normals, np.zeros_like(normals)[:, :1]], axis=-1)
        vertex_normal = np.core.records.fromarrays(normals.transpose(1, 0), names='nx, ny, nz', formats='f4, f4, f4')
        assert len(vertex_normal) == num_vertex
        desc = desc + vertex_normal.dtype.descr
    if colors is not None:
        assert len(colors) == num_vertex
        if colors.max() <= 1:
            colors = colors * 255
        if colors.shape[1] == 4:
            vertex_color = np.core.records.fromarrays(colors.transpose(1, 0), names='red, green, blue, alpha', formats='u1, u1, u1, u1')
        else:
            vertex_color = np.core.records.fromarrays(colors.transpose(1, 0), names='red, green, blue', formats='u1, u1, u1')
        desc = desc + vertex_color.dtype.descr
    vertex_all = np.empty(num_vertex, dtype=desc)
    for prop in vertex.dtype.names:
        vertex_all[prop] = vertex[prop]
    if normals is not None:
        for prop in vertex_normal.dtype.names:
            vertex_all[prop] = vertex_normal[prop]
    if colors is not None:
        for prop in vertex_color.dtype.names:
            vertex_all[prop] = vertex_color[prop]
    ply = plyfile.PlyData([plyfile.PlyElement.describe(vertex_all, 'vertex')], text=not binary)
    if not os.path.exists(os.path.dirname(filename)):
        os.makedirs(os.path.dirname(filename))
    ply.write(filename)
```
</details>
<!---Documatic-block-DSS.utils.io.save_ply-end--->
<!---Documatic-section-save_ply-end--->

# #
<!---Documatic-section-DSS.utils.io.save_ply-end--->

<!---Documatic-section-DSS.utils.__init__.gather_with_neg_idx-start--->
## DSS.utils.__init__.gather_with_neg_idx

<!---Documatic-section-gather_with_neg_idx-start--->
<!---Documatic-block-DSS.utils.__init__.gather_with_neg_idx-start--->
<details>
	<summary><code>DSS.utils.__init__.gather_with_neg_idx</code> code snippet</summary>

```python
def gather_with_neg_idx(input: torch.Tensor, dim: int, index: torch.Tensor, out: Optional[torch.Tensor]=None, sparse_grad: bool=False) -> torch.Tensor:
    mask = index >= 0
    index[~mask] = 0
    out = torch.gather(input, dim, index, out=out, sparse_grad=sparse_grad)
    out[~mask] = 0
    return out
```
</details>
<!---Documatic-block-DSS.utils.__init__.gather_with_neg_idx-end--->
<!---Documatic-section-gather_with_neg_idx-end--->

# #
<!---Documatic-section-DSS.utils.__init__.gather_with_neg_idx-end--->

<!---Documatic-section-DSS.utils.__init__.get_per_point_visibility_mask-start--->
## DSS.utils.__init__.get_per_point_visibility_mask

<!---Documatic-section-get_per_point_visibility_mask-start--->
<!---Documatic-block-DSS.utils.__init__.get_per_point_visibility_mask-start--->
<details>
	<summary><code>DSS.utils.__init__.get_per_point_visibility_mask</code> code snippet</summary>

```python
def get_per_point_visibility_mask(pointclouds: Pointclouds, fragments: NamedTuple) -> Pointclouds:
    P_total = pointclouds.num_points_per_cloud().sum().item()
    try:
        mask = fragments.occupancy.bool()
    except:
        mask = fragments.idx[..., 0] >= 0
    pts_visibility = torch.full((P_total,), False, dtype=torch.bool, device=pointclouds.device)
    visible_idx = fragments.idx[mask].unique().long().view(-1)
    visible_idx = visible_idx[visible_idx >= 0]
    pts_visibility[visible_idx] = True
    return pts_visibility
```
</details>
<!---Documatic-block-DSS.utils.__init__.get_per_point_visibility_mask-end--->
<!---Documatic-section-get_per_point_visibility_mask-end--->

# #
<!---Documatic-section-DSS.utils.__init__.get_per_point_visibility_mask-end--->

<!---Documatic-section-DSS.utils.__init__.num_points_2_cloud_to_packed_first_idx-start--->
## DSS.utils.__init__.num_points_2_cloud_to_packed_first_idx

<!---Documatic-section-num_points_2_cloud_to_packed_first_idx-start--->
<!---Documatic-block-DSS.utils.__init__.num_points_2_cloud_to_packed_first_idx-start--->
<details>
	<summary><code>DSS.utils.__init__.num_points_2_cloud_to_packed_first_idx</code> code snippet</summary>

```python
def num_points_2_cloud_to_packed_first_idx(num_points):
    cloud_to_packed_first_idx = F.pad(num_points, (1, 0), 'constant', 0)
    cloud_to_packed_first_idx = cloud_to_packed_first_idx.cumsum(0)
    return cloud_to_packed_first_idx[:-1]
```
</details>
<!---Documatic-block-DSS.utils.__init__.num_points_2_cloud_to_packed_first_idx-end--->
<!---Documatic-section-num_points_2_cloud_to_packed_first_idx-end--->

# #
<!---Documatic-section-DSS.utils.__init__.num_points_2_cloud_to_packed_first_idx-end--->

<!---Documatic-section-DSS.utils.mathHelper.eps_sqrt-start--->
## DSS.utils.mathHelper.eps_sqrt

<!---Documatic-section-eps_sqrt-start--->
<!---Documatic-block-DSS.utils.mathHelper.eps_sqrt-start--->
<details>
	<summary><code>DSS.utils.mathHelper.eps_sqrt</code> code snippet</summary>

```python
def eps_sqrt(squared, eps=1e-17):
    return torch.clamp(squared.abs(), eps)
```
</details>
<!---Documatic-block-DSS.utils.mathHelper.eps_sqrt-end--->
<!---Documatic-section-eps_sqrt-end--->

# #
<!---Documatic-section-DSS.utils.mathHelper.eps_sqrt-end--->

<!---Documatic-section-DSS.utils.mathHelper.to_homogen-start--->
## DSS.utils.mathHelper.to_homogen

<!---Documatic-section-to_homogen-start--->
<!---Documatic-block-DSS.utils.mathHelper.to_homogen-start--->
<details>
	<summary><code>DSS.utils.mathHelper.to_homogen</code> code snippet</summary>

```python
def to_homogen(x, dim=-1):
    if dim < 0:
        dim = x.ndim + dim
    shp = x.shape
    new_shp = shp[:dim] + (1,) + shp[dim + 1:]
    x_homogen = x.new_ones(new_shp)
    x_homogen = torch.cat([x, x_homogen], dim=dim)
    return x_homogen
```
</details>
<!---Documatic-block-DSS.utils.mathHelper.to_homogen-end--->
<!---Documatic-section-to_homogen-end--->

# #
<!---Documatic-section-DSS.utils.mathHelper.to_homogen-end--->

<!---Documatic-section-DSS.utils.__init__.valid_value_mask-start--->
## DSS.utils.__init__.valid_value_mask

<!---Documatic-section-valid_value_mask-start--->
<!---Documatic-block-DSS.utils.__init__.valid_value_mask-start--->
<details>
	<summary><code>DSS.utils.__init__.valid_value_mask</code> code snippet</summary>

```python
def valid_value_mask(tensor: torch.Tensor):
    return torch.isfinite(tensor) & ~torch.isnan(tensor)
```
</details>
<!---Documatic-block-DSS.utils.__init__.valid_value_mask-end--->
<!---Documatic-section-valid_value_mask-end--->

# #
<!---Documatic-section-DSS.utils.__init__.valid_value_mask-end--->

<!---Documatic-section-DSS.utils.__init__.slice_dict-start--->
## DSS.utils.__init__.slice_dict

<!---Documatic-section-slice_dict-start--->
<!---Documatic-block-DSS.utils.__init__.slice_dict-start--->
<details>
	<summary><code>DSS.utils.__init__.slice_dict</code> code snippet</summary>

```python
def slice_dict(d: dict, idx: List):
    for (k, v) in d.items():
        if isinstance(v, dict):
            slice_dict(v, idx)
        else:
            d[k] = v[idx]
    return d
```
</details>
<!---Documatic-block-DSS.utils.__init__.slice_dict-end--->
<!---Documatic-section-slice_dict-end--->

# #
<!---Documatic-section-DSS.utils.__init__.slice_dict-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)